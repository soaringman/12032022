import Foundation

/*
 
 Фукциональное программирование в Swift или фукции высшего порядка
 
 */

//Простая фильтрация массива
//Фильтрация старым способом (Императивная версия)

var evens = [Int]()
for i in 1...10 {
    if i % 2 == 0 {
        evens.append(i)
    }
}
print(evens)

//Функциональная фильтрация

func isEven(number: Int) -> Bool {
    return number % 2 == 0
}
evens = Array(1...10).filter(isEven)
print(evens)

/*
 Давайте рассмотрим более подробно функциональную версию. Она состоит из двух
 частей:
 
    1. Раздел Array(1...10) представляет собой простой и удобный способ
 создавания массива и содержит числа от 1 до 10. Оператор диапазона 1...10
 создает диапазон, который вы передаете инициализатору массива.
 
    2. Выражение filter - это место, где происходит магия функционального
 программирования.
 Этот метод, раскрытый через Array, создает и возвращает новый массив,
 содержащий только элементы, для которых данная функция возвращает True.
 В этом примере isEven подается на filter.

 Вы передаете функцию isEven в качестве параметра для фильтрации, но запомните,
 что функции теперь стали называться замыканиями. Попробуйте добавить следующую,
 более короткую версию playground:
 
 */

evens = Array(1...10).filter { (number) in number % 2 == 0 }
print(evens)

/*
 Убедитесь, что результаты всех трех вариантов одинаковые. Приведенный выше
 пример показывает, что компилятор выводит тип параметра числа и возвращает типы
 замыкания из контекста использования.
 
 Если вы хотите, что бы ваш код стал еще более коротким, то используйте
 следующее:
 */

evens = Array(1...10).filter { $0 % 2 == 0 }
print(evens)

/*
 Код выше использует сокращенное обозначение аргумента, неявные сокращения...,
 вывод типа... И это работает!
 
 Функциональная версия кода, безусловно более краткая, чем его императивный
 эквивалент.
 Этот простой пример демонстрирует несколько интересных особенностей, общих для
 всех функциональных языков:
 
    1. == Higer-order functions == (Функции высшего порядка): Это функции,
 которые вы передаете в качестве аргументов другим функциям.
 В вышеуказанном простом примере фильтр требует передачи функции высшего порядка
 
    2. == First-class function == (Функции первого класса): Вы можете
 рассматривать функции, как любую другую переменную. Вы можете присвоить их
 переменным и передать их в качестве аргументов другим функциям
 
    3. == Closures == (Замыкания): Это фактически анонимные функции, которые вы
 создаете на месте.
 */

/*
 Магия фильтров
 
 Массивы в свифт имеют ряд функциональных методов, таких как MAP, JOIN, REDUCE.
 Что собственно происходит под капотом этих функций?
 */

/*
 Добавим для понимания сначала императивный код
 */

func myFilter<T>(source: [T], predicate: (T) -> Bool) -> [T] {
    var result = [T]()
    for i in source {
        if predicate(i) {
            result.append(i)
        }
    }
    return result
}

var myEvens = [Int]()
for  j in 1...10 {
    if j % 2 == 0 {
        myEvens.append(j)
    }
}

var myEvensSymm = 0
for j in myEvens {
    myEvensSymm += j
}

print(myEvensSymm)

/*
 А теперь используя встроенные функции так-же найдем сумму всех четных элементов
 массива
 */

 let evenSym = Array(1...10)
    .filter { (number) in number % 2 == 0 }
    .reduce(0) { (total, number) in total + number }
print(evenSym)
